语言的边界：怎么写一定是错的，怎么写一定是对的。

思考：如何定义一门语言？

eg.自然语言-中文

- 句子 -> 主语 谓语 宾语
- 主语 -> 代词|名词|短语
- 代词 -> 你|我|他

# 一、产生式的基本概念

进一步定义产生式：

- Symbol 符号，就是：定义的语法结构名称
  - Terminal Symbol 终结符`or终端符`：不由其它符号定义的符号，即不会出现在产生式左边
  - Non-Terminal Symbol 非终结符：由其它符号经过“与”、“或”等逻辑组成的符号
- 语言定义：语言可以由一个非终结符和它的`产生式`来定义
- `语法树`：把一段具体的语言的文本，根据产生式生成最终定义的非终结符，以树形结构来表示出来

产生式的写法：

## BNF

巴科斯-诺尔范式 `两个人名`

- <中文>::= <句子> | <中文> <句子>
- <句子>::= <主语> <谓语> <宾语> | <主语> <谓语>
- <主语>::= <代词>|<名词>|<名词性短语>
- <代词>::="你"| "我" | "他"

> 用递归的思想

它的特点是：

- 非终结符都用<>括起来（语法上的噪音比较多）
- 终结符用""包裹（像字符串，表示文本）
- ::= 表示定义
- | 或
- 若可以省略就多写几个分支（后面会有改进的写法）

## EBNF

扩展巴科斯-诺尔范式

- 中文 ::= { 句子 }
- 句子 ::= 主语 谓语 [ 宾语 ]
- 主语 ::= 代词 | 名词 | 名词性短语
- 代词 ::="你"| "我" | "他"

写法上：

- 非终结符不强制加<>（因为终结符已经用""区分了）
- {} 可重复多个，表示 0~n 个
- [] 可以省略，表示 0~1 个

EBNF 噪音比较小，所以在国际上比较流行。

## 小结

对语言有一种系统性的了解，必须要有产生式的想法，脑子里需要有这么个概念。

在真正的语言标准实践里，很少有严格按照 BNF 或者 EBNF 来描述语言的。
如果多看几种语言的语言标准（Python/Ruby/C++ 等）没有按照 BNF 来描述的。
网上会把产生式用 BNF 来替代，概念上是行得通的，但是严谨地说肯定不是。

- 产生式：在计算机中指 Tiger 编译器将源程序经过词法分析（Lexical Analysis）和语法分析（Syntax Analysis）后得到的一系列符合文法规则（Backus-Naur Form，BNF）的语句
- 终结符： 最终在代码中出现的字符
- 巴科斯诺尔范式：即巴科斯范式（英语：Backus Normal Form，缩写为 BNF）是一种用于表示上下文无关文法的语言，上下文无关文法描述了一类形式语言。它是由约翰·巴科斯（John Backus）和彼得·诺尔（Peter Naur）首先引入的用来描述计算机语言语法的符号集。

https://zh.wikipedia.org/wiki/%E7%B5%82%E7%B5%90%E7%AC%A6%E8%88%87%E9%9D%9E%E7%B5%82%E7%B5%90%E7%AC%A6

https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F

# 二、形式化语言

产生式在语言中的应用，以及一些基本知识  
用产生式定义的语言，都叫形式化语言  
形式化语言的理论工作，eg.`乔姆斯基 对形式化语言的分类`。

## 乔姆斯基谱系

- 3 型 正则文法 (Regular) `也有翻译成：正规文法`
  - `<A> ::= <A>?`
  - `<A> ::= ?<A>` `不对`
- 2 型 上下文无关文法
  - `<A> ::= ?`
- 1 型 上下文相关文法
  - `?<A>? ::= ?<B>?`
- 0 型 无限制文法
  - `? ::= ?`

> 是包含的关系，0-1-2-3 型越来越严格  
> 在计算机中，语言大部分都是 3 型和 2 型的  
> 1 型和 0 型，基本就是语言学家们为了完备性去做的定义

说明：

- 正则表达式能表示的文法 和 正则文法是等效的
- 正则文法的规定：
  - 定义的左边只允许有一个非终结符
  - 它的右边，在非递归的情况下随便写，在递归情况下只允许左递归
  - eg.连加/连乘时的递归自身在左边
  - eg.”消除左递归“
- 上下文无关文法：只要左侧只有一个非终结符，定义出来的一定是上下文无关文法

编程语言本身是具有一定的复杂性的。
如果我们真正要写语言的编译器、语法解析、文法解析，里面都会有一些“脏代码”。
要不然就会有个通用的处理“乔姆斯基谱系”的代码了。
会为了便捷性，而忽略定义的严格性。

大部分语言会定义两份规范：词法规范+语法规范（统称文法 Grammer）

1. 词法规范：用正则处理，会得到基本的分词->token`有效的词`（去掉空白换行注释等留下有效部分）
   - 把语言当成正则文法，去定义它的词法部分，目标是把 token 挑出来（语言的词法解析）
   - 词法 lex，（编译工具 or 解释器，对应的 lexer 词法分析器）
2. 语法规范
   - Syntax
   - 拿到 token，会把它当成 2 型的语言（上下文无关文法）来处理
   - 目标：得到一颗语法树（由产生式聚合而成的一棵树，如果去掉一些无效信息则会得到抽象语法树 AST）`babel主要做这个事情`

所以，大部分语言有两种产生式：词法产生式、语法产生式

> 第 2 小节：语言类的内容挺多的

## 名词

- 乔姆斯基谱系：是计算机科学中刻画形式文法表达能力的一个分类谱系，是由诺姆·乔姆斯基于 1956 年提出的。它包括四个层次：
  - 0- 型文法（无限制文法或短语结构文法）包括所有的文法。
  - 1- 型文法（上下文相关文法）生成上下文相关语言。
  - 2- 型文法（上下文无关文法）生成上下文无关语言。
  - 3- 型文法（正规文法）生成正则语言。
- Brainfuck ：一种极小化的程序语言，它是由 Urban Müller 在 1993 年创造的。由于 fuck 在英语中是脏话，这种语言有时被称为 Brainfck 或 Brainf\*\*，或被简称为 BF。

# 三、用产生式定义 JavaScript 的词法和语法

> 词法、语法 -> 语义、运行时

详见《JS 产生式》
